<script>

const PENDING = 'pending'
const FULFILLED = 'fulfilled'
const REJECTED = 'rejected'

function MyPromise(executor) {
  debugger
  this.state = PENDING
  this.value = null
  this.reason = null

  // 由于.then 接收两个参数
  this.onFulfilledCallbacks = []
  this.onRejectedCallbacks = []

  const resolve = (value) => {
    if (this.state === PENDING) {
      this.state = FULFILLED
      this.value = value
      this.onFulfilledCallbacks.forEach(fun => {
        fun()
      })
    }
  }

  const reject = (reason) => {
    if (this.state === PENDING) {
      this.state = REJECTED
      this.reason = reason
      this.onRejectedCallbacks.forEach(fun => {
        fun()
      })
    }
  }
  try {
    executor(resolve, reject)
  } catch (reason) {
      reject(reason)
  }
}

MyPromise.prototype.then = function (onFulfilled, onRejected) {
  debugger
  // 以下的所有函数调用，暂可使用 setTimeout 来进行异步调用，
  // 缺点 没有微任务概念。
  switch(this.state) {
    case FULFILLED:
      onFulfilled(this.value)   
      break
    case REJECTED:
      onFulfilled(this.value)
      break
    case PENDING:
      this.onFulfilledCallbacks.push(() => {
        onFulfilled(this.value)
      })
      this.onRejectedCallbacks.push(() => {
        onRejected(this.reason)
      })
      break
  }
}

// 阶段1 初始阶段，未能保证微任务和宏任务
// console.log('window.before')
var promise = new MyPromise((resolve, reject) => {
  resolve(1)
})

// setTimeout(() => {
//   console.log('timeOut.before')
// })

promise.then(res => {
  console.log(res)
})

// setTimeout(() => {
//   console.log('timeOut.after')
// })

// console.log('window.after')


</script>